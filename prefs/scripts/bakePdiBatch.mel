/*
// ==========================================================================
// Copyright (C) 2010 - 2011 Thinkinetic.  All 
// rights reserved.
// 
// The coded instructions, statements, computer programs, and/or related 
// material (collectively the "Data") in these files contain unpublished 
// information proprietary to Carlos Pegar.
// 
// The Data may not be disclosed or distributed to third parties or be 
// copied or duplicated, in whole or in part, without the prior written 
// consent of Thinkinetic.
// 
// The copyright notices in the Software and this entire statement, 
// including the above license grant, this restriction and the following 
// disclaimer, must be included in all copies of the Software, in whole 
// or in part, and all derivative works of the Software, unless such copies 
// or derivative works are solely in the form of machine-executable object 
// code generated by a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
// THINKINETIC DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED 
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF 
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
// OR ARISING FROM A COURSE OF DEALING, USAGE, OR TRADE PRACTICE. IN NO 
// EVENT WILL THINKINETIC  BE LIABLE FOR ANY LOST 
// REVENUES, DATA, OR PROFITS, OR SPECIAL, DIRECT, INDIRECT, OR 
// CONSEQUENTIAL DAMAGES, EVEN IF THINKINETIC HAS 
// BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES. 
// ==========================================================================

*/

/////////////////////////////////////////////////////////////////////////////////
//
//  launch: mayabatch -script "bakePdiBatch" -command "bakePdiBatch"
//
////////////////////////////////////////////////////////////////////////////////7
global proc bakePdiBatchSimulation()
{
    global int $actframe;
    global string $fieldPdiKeysThr;
    global string $fieldPdiRotKeysThr;
    global float $pdiTranslateKeysTreshold;
    global float $pdiAngularKeysTreshold;

//    cycleCheck -e off;

    string $transform[];
    string $pdiSelection[];
//    $pdiSelection = `textScrollList -query -allItems $pdiBodiesList`;
	$pdiSelection = `ls -dag -leaf -type pdiRigidBody`;

    int $i=0;
    string $dynamicSelection[];
    for( $obj in $pdiSelection)
    {
        int $enabled = getAttr ($obj + ".enabled" );
		int $passive = getAttr ($obj + ".passive" );
	    if($enabled > 0 && $passive == 0 )
	    {
            $dynamicSelection[$i] = $obj;$i++;
            setAttr ($obj + ".hasPdiKeys" ) true;
//            delete -sc -c -timeAnimationCurves true $obj;
        }
    }

//    dResumeSim $dynamicSelection;// just in case resume simulation

    string $solver = `pdiSolver`;

     //disable cache
     setAttr ($solver + ".cacheActive" ) false;
     setAttr ($solver + ".cachedMode" ) false;

     //force update
     getAttr ($solver + ".ca_solverParams" );

    int $startTime = `playbackOptions -query -minTime`;
    int $endTime = `playbackOptions -query -maxTime`;

    int $simTine = $endTime - $startTime;


    $initTimer = `timerX`;
    // code that is being timed
    if( $pdiTranslateKeysTreshold == 0.0 && $pdiAngularKeysTreshold==0.0)
    {
        print ("Bake fast");

        string $dynamicSelectionTransform[];

        for( $obj in $dynamicSelection)
        {
            string $parentobject[] =`listRelatives -p $obj`;
            $dynamicSelectionTransform[size($dynamicSelectionTransform)] =  $parentobject[0];
        }
        string $timelapse = $startTime +":" + $endTime;
        bakeResults -t $timelapse -sm true $dynamicSelectionTransform ; 
        clear($dynamicSelectionTransform);
    }
    else
    {
        for($actframe=$startTime; $actframe <= $endTime; $actframe++ )
        {  
	        currentTime -edit $actframe -update true;
             
            int $j;
            for( $j = 0; $j  < size($dynamicSelection); $j++)
            {
		        int $passive = getAttr ($dynamicSelection[$j] + ".passive" );

                if( $passive > 0)
                {
                    continue;
                }

                $transform = `listRelatives -parent $dynamicSelection[$j]`;

                if( size( $transform) > 0)
                {
                    //bake translation
	                float  $linX    = `getAttr ($transform[0] + ".translateX")`;
	                float  $linY    = `getAttr ($transform[0] + ".translateY")`;
	                float  $linZ    = `getAttr ($transform[0] + ".translateZ")`;
                    
                    float  $dist = 1000000.0;
                    if( $actframe > $startTime)
                    {
                        vector $pos0 = getAttr ($dynamicSelection[$j] + ".lastPosition" );

                        float  $distX = ( $linX - ($pos0.x)); 
                        float  $distY = ( $linY - ($pos0.y)); 
                        float  $distZ = ( $linZ - ($pos0.z)); 
                        $dist = $distX*$distX + $distY*$distY +$distZ*$distZ;
                    }
                    
                    if( $dist > $pdiTranslateKeysTreshold)
                    {
//                        string $keytras =  "key tras : " + $linX + " " + $linY + " " + $linZ + "\n";
//                        print $keytras;

	                    setKeyframe -v $linX -at translateX $transform[0];
	                    setKeyframe -v $linY -at translateY $transform[0];
	                    setKeyframe -v $linZ -at translateZ $transform[0];

                        setAttr ($dynamicSelection[$j] + ".lastPosition" ) -type "double3" $linX $linY $linZ;
                    }

                    //bake rotation
	                float  $angleX    = `getAttr ($transform[0] + ".rotateX")`;
	                float  $angleY    = `getAttr ($transform[0] + ".rotateY")`;
	                float  $angleZ    = `getAttr ($transform[0] + ".rotateZ")`;

                    int $bEqual = 0;                         
                    if( $actframe > $startTime)
                    {
                         vector $rot0 = getAttr ($dynamicSelection[$j] + ".lastRotation" );

                         $bEqual = `dComputeRotDist -rx $angleX -ry $angleY -rz $angleZ
                                    -rx2 ($rot0.x) -ry2 ($rot0.y) -rz2 ($rot0.z)
                                    -tol $pdiAngularKeysTreshold`;
                    }

                    if( $bEqual == 0 )
                    {
//                        string $keyrot =  "key rot : " + $angleX + " " + $angleY + " " + $angleZ + "\n";
//                        print $keyrot;

	                    setKeyframe -v $angleX -at rotateX $transform[0];
	                    setKeyframe -v $angleY -at rotateY $transform[0];
	                    setKeyframe -v $angleZ -at rotateZ $transform[0];

                        setAttr ($dynamicSelection[$j] + ".lastRotation" ) -type "double3" $angleX $angleY $angleZ;
                    }
                }
            }
        }
    }
    ////diconnect pdi dynamics
    //string $time[];
    //$time = `ls -type time`;

    //disconnectAttr ($time[0] + ".outTime") ($solver + ".inTime");

    $totalTimer = `timerX -startTime $initTimer`;
    print ("Total Time: "+$totalTimer+"\n");
}

global proc procedureName(string $pluginName)
{
    string $solver = `pdiSolver`;

    string $filename = `file -o "d:/scenes/maya/tests/sphericShelvesPdi.mb"`;

//    print $solver;
    bakePdiBatchSimulation();
//    bakeResults -t "1:100"-simulation true column20;
    deleteAllBodiesFromPdiWorldWithoutConfirm();

    file -rename "batchKeys";
    file -save;
    string $filename = `file -q -sn`;
    print ("file saved as: " + $filename);

}

global proc bakePdiBatch()
{
	string  $result[];
//    print ("Maya batch mode");
//    $result = `loadPlugin -ac procedureName pdiMaya `;
//    scriptJob -protected -event "quitApplication" backupPrefs;
    $result = `loadPlugin pdiMaya `;

///////////////////////////////////////////////////////////
//
//                 INPUT THE PATH TO FILE
//
//////////////////////////////////////////////////////////
    string $filename = `file -o "C:/DATOS/scenes/standard/sphericShelvesPdi.mb"`;

    print ("\n----------------------------------------------------------");
    print ("\n Baking : " + $filename);
    print ("\n----------------------------------------------------------\n");

    string $PDISolver = `pdiSolver`;

///////////////////////////////////////////////////////////
//
//                  SET NUM THREADS
//
//////////////////////////////////////////////////////////
     int $numThreads=4;
     setAttr( $PDISolver + ".numThreads" ) $numThreads;
     //force update
     getAttr ($PDISolver + ".ca_numThreads" );

///////////////////////////////////////////////////////////
//
//                  SET SUBSTEP
//
//////////////////////////////////////////////////////////
     int $substep=20;
     setAttr( $PDISolver + ".substeps" ) $substep;
     //force update
     getAttr ($PDISolver + ".ca_solverParams" );
///////////////////////////////////////////////////////////
//
//                  SET TIME RANGE
//
//////////////////////////////////////////////////////////
    int $minTime=1;
    int $maxTime=200;
    playbackOptions -min $minTime -max $maxTime;

///////////////////////////////////////////////////////////
//
//                  SET KEYS THRESHOLD
//
//////////////////////////////////////////////////////////
    global float $pdiTranslateKeysTreshold = 0.0;//default 0.005;
    global float $pdiAngularKeysTreshold = 0.0;//default 0.120;

    catchQuiet ( `bakePdiBatchSimulation` );

    deleteAllBodiesFromPdiWorldWithoutConfirm();

///////////////////////////////////////////////////////////
//
//                  SAVE THE FILE
//
//////////////////////////////////////////////////////////
    string $savefilename = "batchKeys";
    file -rename $savefilename;
    file -save;
    string $pathfilename = `file -q -sn`;
    print ("file saved as: " + $pathfilename);
}
